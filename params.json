{"name":"Lein-cooper","tagline":"Foreman style plugin for Leiningen for running long running dev tasks in parallel.","body":"# lein-cooper\r\n\r\n> __cooper__ / co-op (per) / co-operative processes.\r\n\r\nA Leiningen plugin that can be used to combine multiple long runnning processes and pipe their output and error streams to `stdout` in a distinctive manner.\r\n\r\nA __long running process__ in this case is one that runs indefinitley and requires human interaction to stop.  Cooper will not play well with something that runs for a while and stops when it is done.  Thing server processes or file watchers and auto test runners.\r\n\r\n`lein-cooper` follows the standard set out by Rubys [Foreman](https://github.com/ddollar/foreman) gem and processes are defined in a `Procfile` at the root of the project.  Each line is a process name and related command.  A sample Procfile looks like this,\r\n\r\n```\r\nweb: lein ring server\r\n jsx: jsx --watch src/ build/\r\n```\r\n\r\nThis example defines 2 processes web and jsx.\r\n\r\n- `web` runs the ring server\r\n- `jsx` runs the react.js precompiler in auto compile mode.\r\n\r\nThis avoids having to manage checking on multiple windows and checking their output.\r\n\r\nWhen processes spit out information to their `out` or `err` streams they are labelled and colour coded for easy distinction.\r\n\r\n> __** CAUTION **__\r\n> \r\n > The JVM is super pants at managing external processes which means that when a processes dies and cooper attempts to kill the other processes there may be some processes left running.  This is due to the fact that when the JVM kills processes it wont kill child process of that process.  There is also no cross paltform way to get a handle on child processes and kill them.\r\n> \r\n> However this is only an issue when a process fails.  When you manually CTRL-C out of the lein cooper command everything will be shutdown as expected so this issue only happens in an error case.\r\n\r\n## Use Cases\r\n\r\nMy need for this came about because I was tinkering with a Clojurescript project and needed to do 2 things.\r\n\r\n1. Run [lein-simpleton](https://github.com/tailrecursion/lein-simpleton) to serve my static content\r\n2. Run [lein-cljsbuild](https://github.com/emezeske/lein-cljsbuild) in `auto` mode to compile my clojurescript on the fly.\r\n\r\nBut any time you have more than one long running process (it needn't be a leiningen task of course, so any sort of web precompilers or auto test runners) then this will bring all the output into a nice single stream.\r\n\r\n> This was created for a personal need and probably goes against typical Clojurarian workflows but everyone has their own flow.  Maybe this will help someone.\r\n\r\n## Usage\r\n\r\n### user-level plugins:\r\n\r\nPut `[lein-cooper \"0.1.0\"]` into the `:plugins` vector of your\r\n`:user` profile.\r\n\r\n### project-level plugins:\r\n\r\nPut `[lein-cooper \"0.1.0-SNAPSHOT\"]` into the `:plugins` vector of your project.clj.\r\n\r\n### Create Procfile\r\n\r\nA procfile is a file containing lists of names processes,\r\n\r\n```\r\n<name>:<command to run>\r\n<name>:<command to run>\r\n<name>:<command to run>\r\n```\r\n\r\nFor example\r\n\r\n```\r\ncljs:  lein cljsbuild auto\r\nweb: lein simpleton 8000\r\n```\r\n\r\n### Run\r\n\r\nThen just run `lein cooper`\r\n\r\n```shell\r\n $ lein cooper\r\n ```\r\n\r\n## License\r\n\r\nCopyright Â© 2014 James Hughes\r\n\r\nDistributed under the Eclipse Public License either version 1.0 or (at\r\nyour option) any later version.\r\n","google":"UA-19143623-5","note":"Don't delete this file! It's used internally to help with page regeneration."}